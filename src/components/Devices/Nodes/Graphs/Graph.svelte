<script lang="ts">
    import "uplot/dist/uPlot.min.css";
    import { onDestroy } from "svelte";
    import { GraphType } from "$lib/logic/view/graph/base";
    import { getGraphToolTipDisplayComponent } from "$lib/logic/view/graph/helpers";
    import { FormattedTimeStep } from "$lib/types/date";
    import { LogSpanPeriod } from "$lib/types/view/nodes";
    import type {
        BaseLogPoint,
        BaseMetrics,
        CounterMetrics,
        MeasurementMetrics,
        ProcessedBaseLogPoint,
        ProcessedCounterLogPoint,
        ProcessedMeasurementLogPoint,
    } from "$lib/types/nodes/logs";
    import FullScreenGraph from "./FullScreenGraph.svelte";
    import Action from "../../../General/Action.svelte";
    import ToolTipText from "../../../General/ToolTipText.svelte";
    import DateRangeChecker from "../../../General/TimeDate/DateRangeChecker.svelte";
    import CircularLoader from "../../../General/CircularLoader.svelte";
    import MeasurementMetricsComponent from "../Metrics/MeasurementMetrics.svelte";
    import CounterMetricsComponent from "../Metrics/CounterMetrics.svelte";
    import GraphToolTip from "./GraphToolTip.svelte";
    import { MeasurementGraphObject } from "$lib/logic/view/graph/measurement";
    import { CounterGraphObject } from "$lib/logic/view/graph/counter";

    // Texts
    import { selectedLang } from "$lib/stores/lang/definition";
    import { texts } from "$lib/stores/lang/generalTexts";

    // Styles
    import { mergeStyle } from "$lib/style/components";
    import { BaseGraphStyle, CounterGraphStyle, GraphActionStyle, GraphMetricStyle, MeasurementGraphStyle } from "$lib/style/graph";

    // Style object (from theme)
    export let style: { [property: string]: string | number } | null = null;
    export let metricsStyle: { [property: string]: string | number } | null = null;
    $: effectiveStyle = style ?? $BaseGraphStyle;
    $: effectiveMetricStyle = metricsStyle ?? $GraphMetricStyle;

    // Props
    export let data: Array<ProcessedBaseLogPoint> | undefined;
    export let timeStep: FormattedTimeStep | null | undefined;
    export let logSpanPeriod: LogSpanPeriod;
    export let fullScreen: boolean = false;
    export let showFullScreen: boolean = false; // Used externally on Full Screen Graph
    export let goBackEnabled: boolean;
    export let graphType: GraphType;
    export let initialDate: Date;
    export let endDate: Date;
    export let dataFetched: boolean;
    export let firstFetch: boolean;
    export let globalMetrics: BaseMetrics | undefined;
    export let unit: string = "";
    export let decimalPlaces: number | null = null;

    // Layout / styling props
    export let width: string | undefined = undefined;
    export let height: string | undefined = undefined;
    export let minHeight: string | undefined = undefined;
    export let headerHeight: string | undefined = undefined;
    export let headerButtonsGap: string | undefined = undefined;
    export let xAxisHeight: string | undefined = undefined;
    export let yAxisWidth: string | undefined = undefined;
    export let unitDivWidth: string | undefined = undefined;
    export let unitMaxWidth: string | undefined = undefined;
    export let borderRadius: string | undefined = undefined;
    export let paddingHorizontal: string | undefined = undefined;
    export let paddingTop: string | undefined = undefined;
    export let paddingBottom: string | undefined = undefined;
    export let backgroundColor: string | undefined = undefined;
    export let borderColor: string | undefined = undefined;
    export let boxShadow: string | undefined = undefined;
    export let graphHeight: string | undefined = undefined;
    export let graphPaddingTop: string | undefined = undefined;
    export let graphPaddingLeft: string | undefined = undefined;
    export let graphPaddingRight: string | undefined = undefined;
    export let graphPaddingBottom: string | undefined = undefined;
    export let graphTextColor: string | undefined = undefined;
    export let graphTextWeight: string | undefined = undefined;
    export let subTextColor: string | undefined = undefined;
    export let subTextWeight: string | undefined = undefined;
    export let scrollbarTrackColor: string | undefined = undefined;
    export let scrollbarThumbColor: string | undefined = undefined;
    export let loaderBackgroundBlur: string | undefined = undefined;

    $: localOverrides = {
        width,
        height,
        minHeight,
        headerHeight,
        headerButtonsGap,
        xAxisHeight,
        yAxisWidth,
        unitDivWidth,
        unitMaxWidth,
        borderRadius,
        paddingHorizontal,
        paddingTop,
        paddingBottom,
        backgroundColor,
        borderColor,
        boxShadow,
        graphHeight,
        graphPaddingTop,
        graphPaddingLeft,
        graphPaddingRight,
        graphPaddingBottom,
        graphTextColor,
        graphTextWeight,
        subTextColor,
        subTextWeight,
        scrollbarTrackColor,
        scrollbarThumbColor,
        loaderBackgroundBlur,
    };

    // Merged style
    $: mergedStyle = mergeStyle(effectiveStyle, localOverrides);

    // Variables

    let graphContainer: HTMLDivElement;
    let gridElement: HTMLDivElement | null = null;
    let graph: any | null = null;
    let showDateRange: boolean = false;
    let loaderTimeout: number | null = null;
    let showLoader: boolean = false;
    let insideGraph: boolean = false;
    let graphCreated: boolean = false;
    let graphNoData: boolean = true;
    let logPoint: BaseLogPoint | null = null;
    let cursorPos: { x: number | undefined; y: number | undefined };
    let resizeObserver: ResizeObserver | null = null;

    // Reactive Statements
    $: if (!dataFetched && !showLoader) {
        if (firstFetch) {
            loaderTimeout = setTimeout(() => {
                showLoader = !dataFetched;
            }, 500);
        } else {
            showLoader = true;
        }
    }
    $: if (dataFetched) {
        if (loaderTimeout) {
            clearTimeout(loaderTimeout);
            loaderTimeout = null;
        }
        showLoader = false;
    }

    $: if (graphType && graphContainer) {
        createGraphObject();
    }

    $: if (graph && dataFetched && data && $selectedLang) {
        updateGraphData();
    }

    $: if (graphContainer && graph) {
        if (!resizeObserver) {
            resizeObserver = new ResizeObserver(() => {
                handleResize();
            });
            resizeObserver.observe(graphContainer);
        }
    }

    // Export Functions
    export let getNewTimeSpan: (startTime: Date, endTime: Date) => void;
    export let goBack: () => void;

    // Functions
    function createGraphObject(): void {
        if (graph) graph.destroy();
        requestAnimationFrame(() => {
            mergedStyle = mergeStyle(effectiveStyle, localOverrides);
            if (graphType === GraphType.Measurement) {
                graph = new MeasurementGraphObject(
                    graphContainer,
                    hoveredLogPointChange,
                    mousePositionChange,
                    gridDoubleClick,
                    data as ProcessedMeasurementLogPoint[],
                );
                Object.assign(mergedStyle, $MeasurementGraphStyle);
            } else if (graphType === GraphType.Counter) {
                graph = new CounterGraphObject(
                    graphContainer,
                    hoveredLogPointChange,
                    mousePositionChange,
                    gridDoubleClick,
                    data as ProcessedCounterLogPoint[],
                );
                Object.assign(mergedStyle, $CounterGraphStyle);
            }
        });
    }

    function hoveredLogPointChange(currentLogPoint: BaseLogPoint | null): void {
        insideGraph = !!currentLogPoint;
        logPoint = currentLogPoint;
    }

    function mousePositionChange(xPos: number | undefined, yPos: number | undefined): void {
        cursorPos = { x: xPos, y: yPos };
    }

    function gridDoubleClick(startTime: Date, endTime: Date): void {
        getNewTimeSpan(startTime, endTime);
    }

    function updateGraphData(): void {
        graph.destroy();
        graph.updatePoints(data, decimalPlaces, true);
        graph.createGraph(timeStep, logSpanPeriod, mergedStyle);
        gridElement = graph.getGridElement();
        graphCreated = true;
        graphNoData = !graph.hasData();
    }

    function handleResize(): void {
        if (graph) {
            graph.resize(mergedStyle);
        }
    }

    onDestroy(() => {
        if (resizeObserver) {
            resizeObserver.disconnect();
            resizeObserver = null;
        }
        if (graph) {
            graph.destroy();
        }
    });
</script>

<div
    style="
        --width: {mergedStyle.width};
        --height: {mergedStyle.height};
        --min-height: {mergedStyle.minHeight};
        --header-height: {mergedStyle.headerHeight};
        --header-buttons-gap: {mergedStyle.headerButtonsGap};
        --x-axis-height: {mergedStyle.xAxisHeight};
        --y-axis-width: {mergedStyle.yAxisWidth};
        --unit-div-width: {mergedStyle.unitDivWidth};
        --unit-max-width: {mergedStyle.unitMaxWidth};
        --border-radius: {mergedStyle.borderRadius};
        --padding-horizontal: {mergedStyle.paddingHorizontal};
        --padding-top: {mergedStyle.paddingTop};
        --padding-bottom: {mergedStyle.paddingBottom};
        --background-color: {mergedStyle.backgroundColor};
        --border-color: {mergedStyle.borderColor};
        --box-shadow: {mergedStyle.boxShadow};
        --graph-height: {mergedStyle.graphHeight};
        --graph-padding-top: {mergedStyle.graphPaddingTop};
        --graph-padding-left: {mergedStyle.graphPaddingTop};
        --graph-padding-right: {mergedStyle.graphPaddingRight};
        --graph-padding-bottom: {mergedStyle.graphPaddingBottom};
        --scrollbar-track-color: {mergedStyle.scrollbarTrackColor};
        --scrollbar-thumb-color: {mergedStyle.scrollbarThumbColor};
        --graph-text-color: {mergedStyle.graphTextColor};
        --graph-text-weight: {mergedStyle.graphTextWeight};
        --sub-text-color: {mergedStyle.subTextColor};
        --sub-text-weight: {mergedStyle.subTextWeight};
        --loader-background-blur: {mergedStyle.loaderBackgroundBlur};
    "
    class="graph-div-container"
>
    <div class="graph-div-wrapper">
        <div class="graph-div-content">
            {#if !fullScreen && showFullScreen}
                <FullScreenGraph
                    {data}
                    {timeStep}
                    {logSpanPeriod}
                    bind:show={showFullScreen}
                    {graphType}
                    {initialDate}
                    {endDate}
                    {dataFetched}
                    {firstFetch}
                    {globalMetrics}
                    {unit}
                    {decimalPlaces}
                    {goBackEnabled}
                    {goBack}
                    {getNewTimeSpan}
                />
            {/if}
            <div class="header">
                <div class="header-content">
                    <div class="left-actions-div">
                        <Action
                            style={$GraphActionStyle}
                            imageURL="/img/previous.svg"
                            disabledImageURL="/img/previous-disabled.svg"
                            onClick={() => goBack()}
                            enableToolTip={true}
                            disabled={!goBackEnabled}
                        >
                            <div slot="tooltip"><ToolTipText text={$texts.goBack} /></div>
                        </Action>
                    </div>
                    <div class="right-header-div">
                        <div class="full-screen-data-range">
                            <DateRangeChecker fullWidth={true} {initialDate} {endDate} />
                        </div>
                        <div class="actions-div">
                            <div class="date-checker-div">
                                <Action
                                    style={$GraphActionStyle}
                                    imageURL="/img/calendar-check.svg"
                                    onClick={() => {
                                        showDateRange = !showDateRange;
                                    }}
                                    enableToolTip={true}
                                >
                                    <div slot="tooltip"><ToolTipText text={$texts.selectedPeriod} /></div>
                                </Action>
                                <DateRangeChecker bind:showToolTip={showDateRange} {initialDate} {endDate} />
                            </div>
                            <Action
                                style={$GraphActionStyle}
                                imageURL="/img/fullscreen.svg"
                                onClick={() => {
                                    showFullScreen = !showFullScreen;
                                }}
                                enableToolTip={true}
                            >
                                <div slot="tooltip"><ToolTipText text={$texts.fullscreen} /></div>
                            </Action>
                        </div>
                    </div>
                </div>
                <div class="metrics-section">
                    {#if globalMetrics}
                        {#if graphType === GraphType.Measurement}
                            <MeasurementMetricsComponent
                                style={effectiveMetricStyle}
                                labelWidth="125px"
                                metrics={globalMetrics as MeasurementMetrics}
                                {unit}
                                {decimalPlaces}
                                {dataFetched}
                                {firstFetch}
                            />
                        {:else if graphType === GraphType.Counter}
                            <CounterMetricsComponent
                                style={effectiveMetricStyle}
                                metrics={globalMetrics as CounterMetrics}
                                {unit}
                                {decimalPlaces}
                                {dataFetched}
                                {firstFetch}
                                roundMetrics={true}
                            />
                        {/if}
                    {/if}
                </div>
            </div>
            <div class="main">
                <div class="loader" class:close={!showLoader}>
                    <CircularLoader wrapperTopLeftRadius="0px" wrapperTopRightRadius="0px" wrapperBottomLeftRadius="0px" wrapperBottomRightRadius="0px" />
                </div>
                <div class="graph-main">
                    <div class="unit-div">
                        <div class="unit-content">
                            <div class="unit-wrapper">
                                {#if graphCreated && !graphNoData}
                                    <span class="unit-label">{unit}</span>
                                {/if}
                            </div>
                        </div>
                    </div>
                    <div class="graph-div" bind:this={graphContainer}>
                        <div class="y-axis-inner-div">
                            <div class="y-axis-inner-content">
                                {#if graphCreated && graphNoData}
                                    <span class="no-data-label">{$texts.noDataAvailable}</span>
                                {/if}
                            </div>
                        </div>
                        {#if graphType && gridElement}
                            <GraphToolTip {gridElement} {insideGraph} {cursorPos}>
                                <svelte:component this={getGraphToolTipDisplayComponent(graphType)} {logPoint} {unit} />
                            </GraphToolTip>
                        {/if}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    .graph-div-container {
        box-sizing: border-box;
        padding-top: var(--padding-top);
        padding-bottom: var(--padding-bottom);
        margin: 0;
        width: var(--width);
        height: var(--height);
        border-radius: var(--border-radius);
        background: var(--background-color);
        border: 1px solid var(--border-color);
        box-shadow: var(--box-shadow);
        container-type: inline-size;
    }

    /* Main graph container - Card-style wrapper with theming and vertical layout */
    .graph-div-wrapper {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        padding-left: var(--padding-horizontal);
        padding-right: var(--padding-horizontal);
        width: 100%;
        height: 100%;
        overflow-x: hidden;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-track-color) var(--scrollbar-thumb-color);
        scrollbar-gutter: stable both-edges;
    }

    .graph-div-content {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: start;
        align-items: center;
        min-height: var(--min-height);
    }

    /* Graph header - Container for action buttons and controls */
    .header {
        margin: 0;
        padding: 0;
        padding-bottom: var(--padding-top);
        position: relative;
        width: 100%;
        height: var(--header-height);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    /* Header content wrapper - Flexible layout for header elements */
    .header-content {
        height: 100%;
        width: 100%;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
    }
    .header-content .right-header-div {
        width: fit-content;
        height: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .right-header-div .full-screen-data-range {
        display: none;
        width: fit-content;
        height: 100%;
    }

    /* Action buttons container - Right-aligned controls with configurable spacing */
    .right-header-div .actions-div {
        width: fit-content;
        height: 100%;
        display: flex;
        justify-content: end;
        align-items: center;
        gap: var(--header-buttons-gap);
    }

    /* Left action buttons container - Left-aligned controls (e.g., back/previous button) */
    .header-content .left-actions-div {
        width: fit-content;
        height: 100%;
        display: flex;
        justify-content: start;
        align-items: center;
        gap: var(--header-buttons-gap);
    }

    /* Date checker container - Houses the date range display tooltip */
    .actions-div .date-checker-div {
        margin: 0;
        padding: 0;
        position: relative;
        width: fit-content;
        height: 100%;
    }

    /* Metrics section - Container for graph metric displays below header actions */
    .metrics-section {
        margin: 0;
        padding: 0;
        width: 100%;
        height: fit-content;
        padding-top: var(--padding-top);
    }

    /* Main content area - Horizontal scrollable container for unit label and graph */
    .main {
        margin: 0;
        padding: 0;
        position: relative;
        width: 100%;
        flex: 1;
        min-height: 0;
    }

    /* Graph main content - Horizontal flex container with styled scrollbar for graph overflow */
    .main .graph-main {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: row;
        justify-content: center;
        align-items: center;
        overflow-x: auto;
        overflow-y: hidden;
        scrollbar-width: thin;
        scrollbar-color: var(--scrollbar-track-color) var(--scrollbar-thumb-color);
        scrollbar-gutter: stable;
    }

    /* Loader overlay - Blurred loading state indicating data unavailability */
    .loader {
        position: absolute;
        inset: 0;
        backdrop-filter: var(--loader-background-blur);
        -webkit-backdrop-filter: var(--loader-background-blur);
        transition: opacity 0.3s ease-in-out;
        z-index: 1;
    }

    /* Close Loader - Fades out and moves to background layer */
    .loader.close {
        opacity: 0;
        z-index: -1;
    }

    /* Unit label section - Left sidebar for measurement unit display */
    .unit-div {
        width: var(--unit-div-width);
        height: var(--graph-height);
    }

    /* Unit content container - Sized to match graph plotting area */
    .unit-content {
        width: 100%;
        height: calc(100% - var(--graph-padding-top) - var(--graph-padding-bottom) - var(--x-axis-height));
        padding-top: var(--graph-padding-top);
        padding-bottom: calc(var(--x-axis-height) + var(--graph-padding-bottom));
    }

    /* Unit wrapper - Relative container for absolutely positioned unit label */
    .unit-wrapper {
        padding: 0;
        margin: 0;
        position: relative;
        width: 100%;
        height: 100%;
    }

    /* Unit label text - Vertically rotated measurement unit (e.g., "kW", "A") */
    .unit-label {
        position: absolute;
        top: 50%;
        left: 50%;
        color: var(--sub-text-color);
        font-weight: var(--sub-text-weight);
        font-size: 13px;
        letter-spacing: 0.5px;
        text-align: center;
        pointer-events: none;
        user-select: none;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        min-width: 0;
        max-width: var(--unit-max-width);
        transform: translate(-50%, -50%) rotate(-90deg);
    }

    /* Graph container - Main plotting area where uPlot charts are rendered */
    .graph-div {
        padding: 0;
        margin: 0;
        position: relative;
        width: calc(100% - var(--unit-div-width));
        height: var(--graph-height);
    }

    /* Y-axis overlay area - Positioned over uPlot's y-axis for custom content */
    .y-axis-inner-div {
        position: absolute;
        left: 0;
        top: 0;
        width: var(--y-axis-width);
        height: calc(var(--graph-height) - var(--graph-padding-top) - var(--graph-padding-bottom) - var(--x-axis-height));
        padding-top: var(--graph-padding-top);
        padding-bottom: calc(var(--x-axis-height) + var(--graph-padding-bottom));
    }

    /* Y-axis content wrapper - Container for y-axis overlay elements */
    .y-axis-inner-content {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        position: relative;
    }

    /* No-data indicator - Rotated text displayed when graph has no data */
    .no-data-label {
        position: absolute;
        top: 50%;
        left: 50%;
        color: var(--sub-text-color);
        font-weight: var(--sub-text-weight);
        font-size: 13px;
        letter-spacing: 0.5px;
        word-spacing: 0.15em;
        opacity: 0.7;
        text-align: center;
        pointer-events: none;
        user-select: none;
        white-space: nowrap;
        transform: translate(-50%, -50%) rotate(-90deg);
    }

    @container (min-width: 880px) {
        .right-header-div .full-screen-data-range {
            display: block;
        }

        .date-checker-div {
            display: none;
        }
    }
</style>
